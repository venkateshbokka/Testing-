#!/usr/bin/env python3
# lorawan_abp_temp.py
# One file: Semtech UDP gateway + ABP end-device (LoRaWAN 1.0.x)
# Sends temperature payload as int16 (째C * 100) on FPort=1, persists FCntUp.

import socket, json, time, base64, secrets, threading, random, os, math
from datetime import datetime, timezone
from binascii import hexlify
from Crypto.Cipher import AES
from Crypto.Hash import CMAC
import struct

# ===================== USER CONFIG =====================
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"
PORT       = 1700

# Gateway EUI (MSB, 16 hex chars)
GATEWAY_EUI_HEX = "0004A30B001CC532"

# ---- ABP device session credentials (MSB, as in TTS) ----
DEVADDR_HEX  = "260B1234"                                    # 4 bytes
NWK_SKEY_HEX = "11223344556677889900AABBCCDDEEFF"            # 16 bytes
APP_SKEY_HEX = "FFEEDDCCBBAA00998877665544332211"            # 16 bytes

# Region preset: "AS923-1", "IN865", "EU868", "US915"
REGION = "AS923-1"
DATARATE = "SF7BW125"
CODR = "4/5"
RSSI, LSNR = -35, 5.0
VERBOSE = True
SEND_CONFIRMED_FIRST = True
UPLINK_PERIOD_SEC = 10
# =======================================================

REGION_FREQS = {
    "AS923-1": [922.0, 922.2, 922.4, 922.6, 922.8, 923.0],
    "IN865":   [865.0625, 865.4025, 865.985],
    "EU868":   [868.1, 868.3, 868.5],
    "US915":   [902.3, 902.5, 902.7, 902.9, 903.1, 903.3, 903.5, 903.7]
}
FREQUENCIES_MHZ = REGION_FREQS.get(REGION, REGION_FREQS["AS923-1"])

def b64e(b): return base64.b64encode(b).decode("ascii")
def to_bytes(h): return bytes.fromhex(h)

GATEWAY_EUI = to_bytes(GATEWAY_EUI_HEX)
DEVADDR     = to_bytes(DEVADDR_HEX)
NWK_SKEY    = to_bytes(NWK_SKEY_HEX)
APP_SKEY    = to_bytes(APP_SKEY_HEX)

print(f"[INFO] Region={REGION}  DR={DATARATE}")
print(f"[INFO] DevAddr={DEVADDR_HEX}  NwkSKey={NWK_SKEY_HEX}  AppSKey={APP_SKEY_HEX}")

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

# ---------- FCntUp persistence ----------
FCNT_FILE = f"fcntup_{DEVADDR_HEX}.txt"
def load_fcnt():
    try:
        with open(FCNT_FILE, "r") as f: return int(f.read().strip())
    except: return 0
def save_fcnt(v):
    try:
        with open(FCNT_FILE, "w") as f: f.write(str(v))
    except Exception as e:
        print(f"[WARN] Could not persist FCntUp: {e}")

# ---------- Temperature encoding ----------
def read_temperature():
    """Simulated temperature in 째C (replace with real sensor if you have one)."""
    t = time.time()
    base = 26.0 + 0.5*math.sin(t/180)      # slow wiggle
    noise = random.uniform(-0.15, 0.15)    # small noise
    return round(base + noise, 2)

def encode_temp_centi(temp_c: float) -> bytes:
    """Return 2 bytes: signed int16 = 째C * 100."""
    val = int(round(temp_c * 100))
    return struct.pack("<h", val)          # little-endian int16

# ---------- LoRaWAN helpers (ABP) ----------
def encrypt_frm(app_skey: bytes, dev_addr: bytes, payload: bytes, fcnt: int) -> bytes:
    out = bytearray(); cipher = AES.new(app_skey, AES.MODE_ECB)
    i = 1; dev_le = dev_addr[::-1]
    while len(out) < len(payload):
        block_a = (b"\x01" + b"\x00"*4 + b"\x00" + dev_le +
                   fcnt.to_bytes(4, "little") + b"\x00" + bytes([i]))
        s = cipher.encrypt(block_a)
        for b in payload[(i-1)*16:i*16]:
            out.append(b ^ s[len(out)%16])
        i += 1
    return bytes(out[:len(payload)])

def mic(nwk_skey: bytes, dev_addr: bytes, mhdr_mac: bytes, fcnt: int) -> bytes:
    dev_le = dev_addr[::-1]
    b0 = (b"\x49" + b"\x00"*4 + b"\x00" + dev_le +
          fcnt.to_bytes(4, "little") + b"\x00" + bytes([len(mhdr_mac)]))
    c = CMAC.new(nwk_skey, ciphermod=AES); c.update(b0 + mhdr_mac)
    return c.digest()[:4]

def build_uplink(payload_bytes: bytes, fcnt: int, confirmed=False, fport: int = 1) -> tuple[bytes, bytes]:
    mhdr = b"\x80" if confirmed else b"\x40"     # Confirmed/Unconfirmed Data Up
    fctrl = b"\x80"                               # ADR bit set (ok for sim)
    fcnt_le = fcnt.to_bytes(2, "little")
    fport_b = bytes([fport])
    enc = encrypt_frm(APP_SKEY, DEVADDR, payload_bytes, fcnt)
    mac = DEVADDR[::-1] + fctrl + fcnt_le + fport_b + enc
    m = mic(NWK_SKEY, DEVADDR, mhdr + mac, fcnt)
    return mhdr + mac + m, m

# ---------- Gateway (Semtech UDP) ----------
def push_data(payload: dict):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",", ":")).encode()
    if VERBOSE:
        print("[GW VERBOSE] PUSH_DATA JSON ->")
        print(json.dumps(payload, indent=2))
    sock.sendto(hdr + body, (TTN_SERVER, PORT))

def pull_data():
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PULL_DATA]) + GATEWAY_EUI
    sock.sendto(hdr, (TTN_SERVER, PORT))
    if VERBOSE: print("[GW VERBOSE] PULL_DATA sent")

def send_status():
    payload = {"stat": {
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT"),
        "lati": 23.0, "long": 72.0, "alti": 20, "rxnb": 0, "rxok": 0,
        "rxfw": 0, "ackr": 0.0, "dwnb": 0, "txnb": 0
    }}
    push_data(payload)

def send_uplink(frame_bytes: bytes, freq_mhz=None, datr=None):
    freq = round(freq_mhz if freq_mhz else random.choice(FREQUENCIES_MHZ), 4)
    datr = datr or DATARATE
    rxpk = [{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": freq, "stat": 1,
        "modu": "LORA", "datr": datr, "codr": CODR,
        "rssi": RSSI, "lsnr": LSNR, "size": len(frame_bytes),
        "data": b64e(frame_bytes)
    }]
    push_data({"rxpk": rxpk})
    print(f"[GW] Uplink sent freq={freq} datr={datr} size={len(frame_bytes)}")

def recv_loop():
    while True:
        try:
            data, _ = sock.recvfrom(65535)
        except socket.timeout:
            continue
        if len(data) < 4 or data[0] != VER: 
            continue
        ptype = data[3]
        if ptype == PUSH_ACK:
            print("[GW] PUSH_ACK (uplink acknowledged)")
        elif ptype == PULL_ACK and VERBOSE:
            print("[GW VERBOSE] PULL_ACK")
        elif ptype == PULL_RESP:
            # ABP demo ignores downlink; still TX_ACK to be polite
            token = data[1:3]
            sock.sendto(bytes([VER]) + token + bytes([TX_ACK]), (TTN_SERVER, PORT))

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print(f"[GW] periodic error: {e}")
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

# ---------- Main ----------
def main():
    threading.Thread(target=recv_loop, daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(send_status, 30)
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX} -> {TTN_SERVER}:{PORT}")

    fcnt = load_fcnt()
    print(f"[INFO] Starting FCntUp from persisted value: {fcnt}")

    confirmed = SEND_CONFIRMED_FIRST
    while True:
        fcnt = (fcnt + 1) & 0xFFFFFFFF
        temp_c = read_temperature()
        payload = encode_temp_centi(temp_c)          # **2 bytes**
        frame, mic_val = build_uplink(payload, fcnt & 0xFFFF, confirmed=confirmed, fport=1)
        print(f"[DEV] Temp={temp_c:.2f} 째C  FCntUp={fcnt}  MIC={hexlify(mic_val).decode().upper()} DR={DATARATE}")
        send_uplink(frame)
        save_fcnt(fcnt)
        confirmed = False
        time.sleep(UPLINK_PERIOD_SEC)

if __name__ == "__main__":
    from datetime import datetime, timezone
    try:
        main()
    except KeyboardInterrupt:
        print("\n[Main] Stopped.")
