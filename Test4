#!/usr/bin/env python3
# lorawan_abp_persist.py
# One file: Semtech UDP gateway + ABP end-device (LoRaWAN 1.0.x)
# - Persists FCntUp across restarts
# - Region presets
# - Verbose debug (MIC, FCnt, keys)

import socket, json, time, base64, secrets, threading, random, os
from datetime import datetime, timezone
from binascii import hexlify
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ===================== USER CONFIG =====================
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"
PORT       = 1700

# Gateway EUI (MSB, 16 hex chars)
GATEWAY_EUI_HEX = "0004A30B001CC532"

# ---- ABP session credentials (MSB as shown in TTS) ----
DEVADDR_HEX  = "260B1234"                                    # 4 bytes
NWK_SKEY_HEX = "11223344556677889900AABBCCDDEEFF"            # 16 bytes
APP_SKEY_HEX = "FFEEDDCCBBAA00998877665544332211"            # 16 bytes

# Region preset: "AS923-1", "IN865", "EU868", "US915"
REGION = "AS923-1"
DATARATE = "SF7BW125"      # keep unless you know you need a different DR
CODR = "4/5"
RSSI, LSNR = -35, 5.0
VERBOSE = True
SEND_CONFIRMED_FIRST = True   # first uplink confirmed, then unconfirmed
UPLINK_PERIOD_SEC = 10
# =======================================================

# ----- region presets (uplink freqs only, examples) -----
REGION_FREQS = {
    "AS923-1": [922.0, 922.2, 922.4, 922.6, 922.8, 923.0],
    "IN865":   [865.0625, 865.4025, 865.985],
    "EU868":   [868.1, 868.3, 868.5],
    "US915":   [902.3, 902.5, 902.7, 902.9, 903.1, 903.3, 903.5, 903.7]  # 8ch example
}
FREQUENCIES_MHZ = REGION_FREQS.get(REGION, REGION_FREQS["AS923-1"])

# ---------- helpers ----------
def b64e(b): return base64.b64encode(b).decode("ascii")
def b64d(s): return base64.b64decode(s + "===")
def to_bytes(hexstr): return bytes.fromhex(hexstr)

GATEWAY_EUI = to_bytes(GATEWAY_EUI_HEX)
DEVADDR     = to_bytes(DEVADDR_HEX)
NWK_SKEY    = to_bytes(NWK_SKEY_HEX)
APP_SKEY    = to_bytes(APP_SKEY_HEX)

print(f"[INFO] Region={REGION}  DR={DATARATE}")
print(f"[INFO] DevAddr={DEVADDR_HEX}  NwkSKey={NWK_SKEY_HEX}  AppSKey={APP_SKEY_HEX}")

# UDP + Semtech UDP constants
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); sock.settimeout(2.0)
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

# ---------- FCntUp persistence ----------
FCNT_FILE = f"fcntup_{DEVADDR_HEX}.txt"
def load_fcnt():
    try:
        with open(FCNT_FILE, "r") as f: return int(f.read().strip())
    except: return 0
def save_fcnt(v):
    try:
        with open(FCNT_FILE, "w") as f: f.write(str(v))
    except Exception as e:
        print(f"[WARN] Could not persist FCntUp: {e}")

# ---------- LoRaWAN payload building (ABP) ----------
def encrypt_frm(app_skey: bytes, dev_addr: bytes, payload: bytes, fcnt: int) -> bytes:
    out = bytearray(); cipher = AES.new(app_skey, AES.MODE_ECB)
    i = 1; dev_le = dev_addr[::-1]
    while len(out) < len(payload):
        block_a = (b"\x01" + b"\x00"*4 + b"\x00" + dev_le +
                   fcnt.to_bytes(4, "little") + b"\x00" + bytes([i]))
        s = cipher.encrypt(block_a)
        for b in payload[(i-1)*16:i*16]:
            out.append(b ^ s[len(out)%16])
        i += 1
    return bytes(out[:len(payload)])

def mic(nwk_skey: bytes, dev_addr: bytes, mhdr_mac: bytes, fcnt: int) -> bytes:
    dev_le = dev_addr[::-1]
    b0 = (b"\x49" + b"\x00"*4 + b"\x00" + dev_le +
          fcnt.to_bytes(4, "little") + b"\x00" + bytes([len(mhdr_mac)]))
    c = CMAC.new(nwk_skey, ciphermod=AES); c.update(b0 + mhdr_mac)
    return c.digest()[:4]

def build_uplink(plaintext: bytes, fcnt: int, confirmed=False) -> tuple[bytes, bytes]:
    mhdr = b"\x80" if confirmed else b"\x40"     # Confirmed/Unconfirmed Data Up
    fctrl = b"\x80"                               # ADR bit set (ok for sim)
    fcnt_le = fcnt.to_bytes(2, "little")
    fport = b"\x01"
    enc = encrypt_frm(APP_SKEY, DEVADDR, plaintext, fcnt)
    mac = DEVADDR[::-1] + fctrl + fcnt_le + fport + enc
    m = mic(NWK_SKEY, DEVADDR, mhdr + mac, fcnt)
    frame = mhdr + mac + m
    return frame, m

# ---------- Gateway (Semtech UDP) ----------
def push_data(payload: dict):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",", ":")).encode()
    if VERBOSE:
        print("[GW VERBOSE] PUSH_DATA JSON ->")
        print(json.dumps(payload, indent=2))
    sock.sendto(hdr + body, (TTN_SERVER, PORT))

def pull_data():
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PULL_DATA]) + GATEWAY_EUI
    sock.sendto(hdr, (TTN_SERVER, PORT))
    if VERBOSE: print("[GW VERBOSE] PULL_DATA sent")

def send_status():
    payload = {"stat": {
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT"),
        "lati": 23.0, "long": 72.0, "alti": 20, "rxnb": 0, "rxok": 0,
        "rxfw": 0, "ackr": 0.0, "dwnb": 0, "txnb": 0
    }}
    push_data(payload)

def send_uplink(frame_bytes: bytes, freq_mhz=None, datr=None):
    freq = round(freq_mhz if freq_mhz else random.choice(FREQUENCIES_MHZ), 4)
    datr = datr or DATARATE
    rxpk = [{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": freq, "stat": 1,
        "modu": "LORA", "datr": datr, "codr": CODR,
        "rssi": RSSI, "lsnr": LSNR, "size": len(frame_bytes),
        "data": b64e(frame_bytes)
    }]
    push_data({"rxpk": rxpk})
    print(f"[GW] Uplink sent freq={freq} datr={datr} size={len(frame_bytes)}")

def recv_loop():
    while True:
        try:
            data, _ = sock.recvfrom(65535)
        except socket.timeout:
            continue
        if len(data) < 4 or data[0] != VER:
            continue
        ptype = data[3]
        if ptype == PUSH_ACK:
            print("[GW] PUSH_ACK (uplink acknowledged)")
        elif ptype == PULL_ACK and VERBOSE:
            print("[GW VERBOSE] PULL_ACK")
        elif ptype == PULL_RESP:
            # ABP demo ignores downlink; still TX_ACK to be polite
            token = data[1:3]
            sock.sendto(bytes([VER]) + token + bytes([TX_ACK]), (TTN_SERVER, PORT))

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print(f"[GW] periodic error: {e}")
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

# ---------- Main ----------
def main():
    # Start gateway background tasks
    threading.Thread(target=recv_loop, daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(send_status, 30)
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX} -> {TTN_SERVER}:{PORT}")

    fcnt = load_fcnt()
    print(f"[INFO] Starting FCntUp from persisted value: {fcnt}")

    confirmed = SEND_CONFIRMED_FIRST
    while True:
        fcnt = (fcnt + 1) & 0xFFFFFFFF  # keep 32-bit local counter
        upl_text = f"temp:{25 + (fcnt % 5)}".encode()
        frame, mic_val = build_uplink(upl_text, fcnt & 0xFFFF, confirmed=confirmed)
        print(f"[DEV] Uplink FCntUp={fcnt} (LoRaWAN {fcnt & 0xFFFF}) "
              f"MIC={hexlify(mic_val).decode().upper()} DR={DATARATE}")
        send_uplink(frame)
        save_fcnt(fcnt)
        confirmed = False
        time.sleep(UPLINK_PERIOD_SEC)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[Main] Stopped.")
