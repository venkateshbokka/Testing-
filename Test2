#!/usr/bin/env python3
# single_lorawan_sim_ack.py
# One file: Semtech UDP gateway + OTAA end device (LoRaWAN 1.0.x)
# Prints when Join-Accept arrives, sends a Confirmed Data Up, and detects the ACK.

import os, json, time, base64, socket, struct, threading, random
from datetime import datetime, timezone
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ===================== CONFIG (edit here) =====================
TTS_HOST   = "127.0.0.1"       # your TTS UDP router host/IP
TTS_PORT   = 1700
GATEWAY_EUI_HEX = "AA555A0000000001"

DEV_EUI_HEX  = "70B3D57ED0052102"
JOIN_EUI_HEX = "0000000000000000"
APP_KEY_HEX  = "8C963B0C26A3AC10AE12238F982237405B"

FREQUENCIES_MHZ = [922.0, 922.2, 922.4, 922.6, 922.8, 923.0]   # AS923 example
DATARATE        = "SF7BW125"
CODR            = "4/5"
RSSI, LSNR      = -35, 5.0
VERBOSE         = True
# =============================================================

VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05
sock=None; server=None; running=False; DOWNLINK_CB=None

def gweui_bytes():
    h=GATEWAY_EUI_HEX.replace(":","").replace("-","").lower()
    if len(h)!=16: raise ValueError("GATEWAY_EUI_HEX must be 16 hex chars")
    return bytes.fromhex(h)

def tok(): return os.urandom(2)
def b64d(s): return base64.b64decode(s + "===")
def hexdump(buf,pfx="[HEX] "):
    for i in range(0,len(buf),16):
        print(f"{pfx}{i:04x}: "+" ".join(f"{b:02X}" for b in buf[i:i+16]))

def push_data(payload):
    hdr = struct.pack(">B2sB", VER, tok(), PUSH_DATA) + gweui_bytes()
    body = json.dumps(payload, separators=(",",":")).encode()
    if VERBOSE: print("[GW VERBOSE] PUSH_DATA ->\n"+json.dumps(payload,indent=2))
    sock.sendto(hdr+body, server)

def pull_data():
    hdr = struct.pack(">B2sB", VER, tok(), PULL_DATA) + gweui_bytes()
    sock.sendto(hdr, server)
    if VERBOSE: print("[GW VERBOSE] PULL_DATA sent")

def tx_ack(token):
    hdr = struct.pack(">B2sB", VER, token, TX_ACK)
    sock.sendto(hdr, server)

def mhdr_kind(mhdr:int):
    return {0:"JoinRequest",1:"JoinAccept",2:"UnconfUp",3:"UnconfDown",4:"ConfUp",5:"ConfDown"}.get((mhdr>>5)&7,"?")

def recv_worker():
    while running:
        try: data,_=sock.recvfrom(65535)
        except socket.timeout: continue
        if len(data)<4 or data[0]!=VER: continue
        token=data[1:3]; ptype=data[3]
        if ptype==PUSH_ACK: print("[GW] PUSH_ACK (uplink acknowledged)")
        elif ptype==PULL_ACK and VERBOSE: print("[GW VERBOSE] PULL_ACK")
        elif ptype==PULL_RESP:
            try:
                js=json.loads(data[4:].decode()); b64=js.get("txpk",{}).get("data")
                if b64:
                    raw=b64d(b64)
                    print(f"[GW] Downlink received ({len(raw)} bytes)")
                    if VERBOSE: hexdump(raw,"[GW VERBOSE] DL ")
                    if DOWNLINK_CB: DOWNLINK_CB(raw)
                    tx_ack(token)
            except Exception as e:
                print(f"[GW] PULL_RESP parse error: {e}")

def loop_every(fn,sec):
    while running:
        try: fn()
        except Exception as e: print(f"[GW] periodic error: {e}")
        time.sleep(sec)

def gateway_start(on_downlink):
    global sock,server,running,DOWNLINK_CB
    DOWNLINK_CB=on_downlink; server=(TTS_HOST,TTS_PORT)
    sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); sock.bind(("0.0.0.0",0)); sock.settimeout(1.0)
    running=True
    threading.Thread(target=recv_worker,daemon=True).start()
    threading.Thread(target=loop_every,args=(pull_data,5),daemon=True).start()
    def send_status():
        push_data({"stat":{"time":datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT"),
                           "lati":23.0,"long":72.0,"alti":20,"rxnb":0,"rxok":0,"rxfw":0,"ackr":0.0,"dwnb":0,"txnb":0}})
    threading.Thread(target=loop_every,args=(send_status,30),daemon=True).start()
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX.upper()} -> {TTS_HOST}:{TTS_PORT}")

def gateway_send_uplink(uplink_b64:str, freq=None, datr=None):
    raw=b64d(uplink_b64); kind=mhdr_kind(raw[0] if raw else 0)
    print(f"[GW] Uplink -> {kind} | {len(raw)} bytes")
    if VERBOSE: hexdump(raw,"[GW VERBOSE] UL ")
    freq = round(freq if freq else random.choice(FREQUENCIES_MHZ),3)
    datr = datr or DATARATE
    rxpk=[{"time":datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
           "tmst":int(time.time()*1_000_000)&0xFFFFFFFF,"chan":0,"rfch":0,"freq":freq,"stat":1,
           "modu":"LORA","datr":datr,"codr":CODR,"rssi":RSSI,"lsnr":LSNR,"size":len(raw),"data":uplink_b64}]
    push_data({"rxpk":rxpk})
    print(f"[GW] Uplink sent freq={freq} datr={datr} size={len(raw)}")

# ---------------- Device ----------------
def aes128_enc(k,b): return AES.new(k,AES.MODE_ECB).encrypt(b)
def cmac(k,m): c=CMAC.new(k,ciphermod=AES); c.update(m); return c.digest()

class OtaaDevice:
    def __init__(s, dev_eui_hex, join_eui_hex, app_key_hex):
        s.dev_eui=bytes.fromhex(dev_eui_hex)[::-1]; s.join_eui=bytes.fromhex(join_eui_hex)[::-1]; s.app_key=bytes.fromhex(app_key_hex)
        s.dev_nonce=0; s.dev_addr=None; s.nwk_skey=None; s.app_skey=None; s.fcnt=0

    def next_nonce(s): s.dev_nonce=(s.dev_nonce+1)&0xFFFF; return s.dev_nonce.to_bytes(2,"little")

    def build_join(s):
        mhdr=b"\x00"; dn=s.next_nonce(); msg=s.join_eui+s.dev_eui+dn; mic=cmac(s.app_key,mhdr+msg)[:4]
        frm=mhdr+msg+mic; print(f"[Device] JoinReq devnonce={dn.hex()} mic={mic.hex()}"); return base64.b64encode(frm).decode(), dn

    def parse_join_accept(s, raw, devnonce):
        if raw[0]>>5!=1: print("[Device] Not JoinAccept"); return False
        dec=AES.new(s.app_key,AES.MODE_ECB).decrypt(raw[1:17])
        app_nonce,net_id,devaddr_le=dec[0:3],dec[3:6],dec[6:10]; s.dev_addr=devaddr_le[::-1]
        s.nwk_skey=aes128_enc(s.app_key, b"\x01"+app_nonce+net_id+devnonce+b"\x00"*7)
        s.app_skey=aes128_enc(s.app_key, b"\x02"+app_nonce+net_id+devnonce+b"\x00"*7)
        print(f"[Device] ✅ Join-Accept received. DevAddr={s.dev_addr.hex().upper()}")
        print(f"[Device] NwkSKey={s.nwk_skey.hex().upper()}")
        print(f"[Device] AppSKey={s.app_skey.hex().upper()}")
        return True

    def _enc_frm(s, pbytes, fcnt):
        out=bytearray(); c=AES.new(s.app_skey,AES.MODE_ECB); i=1; dev_le=s.dev_addr[::-1]
        while len(out)<len(pbytes):
            block=(b"\x01"+b"\x00"*4+b"\x00"+dev_le+fcnt.to_bytes(4,"little")+b"\x00"+bytes([i]))
            sblk=c.encrypt(block); 
            for b in pbytes[(i-1)*16:i*16]: out.append(b ^ sblk[len(out)%16])
            i+=1
        return bytes(out[:len(pbytes)])

    def _mic(s, mhdr_mac, fcnt):
        dev_le=s.dev_addr[::-1]
        b0=(b"\x49"+b"\x00"*4+b"\x00"+dev_le+fcnt.to_bytes(4,"little")+b"\x00"+bytes([len(mhdr_mac)]))
        return cmac(s.nwk_skey, b0+mhdr_mac)[:4]

    def build_data(s, text, confirmed=False):
        s.fcnt=(s.fcnt+1)&0xFFFF
        mhdr=b"\x80" if confirmed else b"\x40"   # ConfirmedUp or UnconfirmedUp
        fctrl=b"\x80"; fcnt_le=s.fcnt.to_bytes(2,"little"); fport=b"\x01"
        enc=s._enc_frm(text.encode(), s.fcnt)
        mac=s.dev_addr[::-1]+fctrl+fcnt_le+fport+enc
        mic=s._mic(mhdr+mac, s.fcnt)
        frm=mhdr+mac+mic
        kind="CONFIRMED" if confirmed else "UNCONFIRMED"
        print(f"[Device] {kind} Uplink fcnt={s.fcnt} bytes={len(frm)}")
        return base64.b64encode(frm).decode()

device=OtaaDevice(DEV_EUI_HEX, JOIN_EUI_HEX, APP_KEY_HEX)
_joined=False; _last_dn=None; _waiting_ack=False

def on_downlink(raw:bytes):
    global _joined,_last_dn,_waiting_ack
    mtype=(raw[0]>>5)&7
    if not _joined:
        if device.parse_join_accept(raw,_last_dn):
            _joined=True
            # Send one CONFIRMED uplink right away
            b64=device.build_data("hello-after-join", confirmed=True)
            _waiting_ack=True
            gateway_send_uplink(b64)
    else:
        # detect ACK for our confirmed uplink (downlink FCtrl ACK bit set)
        if mtype==5 and len(raw)>=5:   # ConfirmedDataDown
            fctrl=raw[1+4]             # MHDR(1) + DevAddr(4) -> FCtrl
            if (fctrl & 0x20)!=0:      # ACK bit
                if _waiting_ack:
                    print("[Device] ✅ ACK received for confirmed uplink")
                    _waiting_ack=False

def send_join_loop():
    global _last_dn
    while not _joined:
        b64,dn=device.build_join(); _last_dn=dn; gateway_send_uplink(b64); print("[Device] JoinReq sent"); time.sleep(5)

def send_data_loop():
    # after ACK (or immediately if network doesn't ACK), send periodic unconfirmed
    while True:
        b64=device.build_data(f"temp:{25 + (device.fcnt % 5)}")
        gateway_send_uplink(b64)
        time.sleep(10)

# ---- main ----
if __name__=="__main__":
    print("[Main] Starting gateway…"); 
    sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); sock.bind(("0.0.0.0",0)); sock.settimeout(1.0)
    server=(TTS_HOST,TTS_PORT); running=True
    threading.Thread(target=recv_worker,daemon=True).start()
    threading.Thread(target=loop_every,args=(pull_data,5),daemon=True).start()
    def send_status():
        push_data({"stat":{"time":datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT"),
                           "lati":23.0,"long":72.0,"alti":20,"rxnb":0,"rxok":0,"rxfw":0,"ackr":0.0,"dwnb":0,"txnb":0}})
    threading.Thread(target=loop_every,args=(send_status,30),daemon=True).start()
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX.upper()} -> {TTS_HOST}:{TTS_PORT}")
    print("[Main] Starting OTAA…")
    threading.Thread(target=send_data_loop,daemon=True).start()  # starts after join
    send_join_loop()
