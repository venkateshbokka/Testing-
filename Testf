#!/usr/bin/env python3
# otaa_as923_temp_full.py
# OTAA (AS923-1) join -> derive session keys -> periodic temperature uplinks
# Gateway + device in one process (Semtech UDP simulator)

import socket, json, time, base64, secrets, threading, random, math, struct, os
from datetime import datetime, timezone
from binascii import hexlify
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ==================== EDIT ME ====================
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"
PORT       = 1700
GATEWAY_EUI_HEX = "0004A30B001CC532"            # 8-byte EUI (MSB)

# Device credentials (MSB exactly as in TTS)
DEV_EUI_HEX  = "70B3D57ED0050B1"
JOIN_EUI_HEX = "1232456845624523"
APP_KEY_HEX  = "8D7C6E5B3A613ACE210E3F98223740D5"

# AS923-1 join (fixes "uplink channel not found")
JOIN_FREQS_MHZ = [923.2, 923.4, 923.6]
JOIN_DATARATE  = "SF10BW125"                    # use "SF9BW125" if your tenant expects DR3

# After join (AS923-1 data channels/DR)
DATA_FREQS_MHZ = [923.2, 923.4, 923.6, 923.8, 924.0, 924.2, 924.4, 924.6]
DATA_DATARATE  = "SF7BW125"                     # typical application DR

UPLINK_PERIOD_SEC = 10
PERSIST_FCNT = True
VERBOSE = True
# ==================================================

# ---------- helpers ----------
def msb_to_lsb(h): return bytes.fromhex(h)[::-1]
def b64e(b): return base64.b64encode(b).decode("ascii")
def b64d(s): return base64.b64decode(s + "===")

GATEWAY_EUI = bytes.fromhex(GATEWAY_EUI_HEX)
DEV_EUI  = msb_to_lsb(DEV_EUI_HEX)
JOIN_EUI = msb_to_lsb(JOIN_EUI_HEX)
APP_KEY  = bytes.fromhex(APP_KEY_HEX)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); sock.settimeout(2.0)
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

def log(*a): print(*a)

# ---------- gateway side ----------
def push_data(payload):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",", ":")).encode()
    sock.sendto(hdr + body, (TTN_SERVER, PORT))
    if VERBOSE and "rxpk" in payload:
        print("[GW] PUSH_DATA rxpk ->", payload["rxpk"][0]["freq"], payload["rxpk"][0]["datr"])

def pull_data():
    token = secrets.token_bytes(2)
    sock.sendto(bytes([VER]) + token + bytes([PULL_DATA]) + GATEWAY_EUI, (TTN_SERVER, PORT))

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print("[GW] periodic error:", e)
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

def send_rxpk(frame_bytes: bytes, freq_mhz: float, datr: str):
    rxpk=[{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": round(freq_mhz, 4), "stat": 1,
        "modu": "LORA", "datr": datr, "codr": "4/5",
        "rssi": -35, "lsnr": 5.0, "size": len(frame_bytes),
        "data": b64e(frame_bytes)
    }]
    push_data({"rxpk": rxpk})

# ---------- OTAA (LoRaWAN 1.0.x) ----------
_used_dnonce=set()
def next_devnonce():
    while True:
        x=secrets.randbits(16)
        if x not in _used_dnonce:
            _used_dnonce.add(x); return x.to_bytes(2,"little")

def cmac(key, msg): c=CMAC.new(key, ciphermod=AES); c.update(msg); return c.digest()

def build_join_request():
    mhdr=b"\x00"  # Join-Request
    dn = next_devnonce()
    msg = mhdr + JOIN_EUI + DEV_EUI + dn
    mic = cmac(APP_KEY, msg)[:4]
    frame = msg + mic
    log(f"[Join] devnonce={dn.hex()} mic={mic.hex()}")
    return frame, dn

def derive_session_keys(app_key, app_nonce, net_id, dev_nonce):
    # LoRaWAN 1.0.x spec formulae
    cipher = AES.new(app_key, AES.MODE_ECB)
    nwk_block = bytes([0x01]) + app_nonce + net_id + dev_nonce + bytes(7)
    app_block = bytes([0x02]) + app_nonce + net_id + dev_nonce + bytes(7)
    return cipher.encrypt(nwk_block), cipher.encrypt(app_block)

def parse_join_accept(raw: bytes, dev_nonce: bytes):
    # Downlink: MHDR | encrypted(Join-Accept fields)
    if (raw[0]>>5)!=1: return None
    enc = raw[1:17]                     # minimal 16 bytes (no CFList parsed here)
    dec = AES.new(APP_KEY, AES.MODE_ECB).decrypt(enc)
    app_nonce = dec[0:3]
    net_id    = dec[3:6]
    devaddr   = dec[6:10][::-1]         # store MSB
    nwk_skey, app_skey = derive_session_keys(APP_KEY, app_nonce, net_id, dev_nonce)
    log(f"[Join] ✅ accepted DevAddr={devaddr.hex().upper()}")
    log(f"[Join] NwkSKey={nwk_skey.hex().upper()}")
    log(f"[Join] AppSKey={app_skey.hex().upper()}")
    return devaddr, nwk_skey, app_skey

# ---------- data uplinks ----------
def enc_frmpayload(app_skey, devaddr, payload, fcnt16):
    out=bytearray(); cipher=AES.new(app_skey, AES.MODE_ECB); i=1; dev_le=devaddr[::-1]
    while len(out)<len(payload):
        block=(b"\x01"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([i]))
        s=cipher.encrypt(block)
        for b in payload[(i-1)*16:i*16]: out.append(b ^ s[len(out)%16])
        i+=1
    return bytes(out[:len(payload)])

def data_mic(nwk_skey, devaddr, mhdr_mac, fcnt16):
    dev_le=devaddr[::-1]
    b0=(b"\x49"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([len(mhdr_mac)]))
    return cmac(nwk_skey, b0+mhdr_mac)[:4]

def read_temperature():
    t=time.time(); base=26.0+0.5*math.sin(t/180); noise=random.uniform(-0.15,0.15)
    return round(base+noise,2)

def encode_temp_centi(temp_c: float) -> bytes:
    val=int(round(temp_c*100)); return struct.pack("<h", val)  # int16 LE

# ---------- state ----------
joined=False
last_dn=b"\x00\x00"
devaddr=None; nwk_skey=None; app_skey=None
fcnt32=0
FCNT_FILE="fcntup_otaa.txt"

def load_fcnt():
    if not PERSIST_FCNT: return 0
    try: return int(open(FCNT_FILE).read().strip())
    except: return 0

def save_fcnt(v):
    if not PERSIST_FCNT: return
    try: open(FCNT_FILE,"w").write(str(v))
    except: pass

# ---------- rx loop ----------
def recv_loop():
    global joined, devaddr, nwk_skey, app_skey
    while True:
        try: data,_=sock.recvfrom(65535)
        except socket.timeout: continue
        if len(data)<4 or data[0]!=VER: continue
        t=data[3]
        if t==PUSH_ACK and VERBOSE: print("[GW] PUSH_ACK")
        elif t==PULL_ACK and VERBOSE: print("[GW] PULL_ACK")
        elif t==PULL_RESP:
            js=json.loads(data[4:].decode()); b64=js.get("txpk",{}).get("data")
            if not b64: continue
            raw=b64d(b64)
            parsed = parse_join_accept(raw, last_dn)
            if parsed:
                token=data[1:3]  # send TX_ACK politely
                sock.sendto(bytes([VER])+token+bytes([TX_ACK]),(TTN_SERVER,PORT))
                devaddr, nwk_skey, app_skey = parsed
                joined=True

# ---------- send loops ----------
def send_data_loop():
    global fcnt32
    fcnt32 = load_fcnt()
    while True:
        if not joined:
            time.sleep(1); continue
        fcnt32 = (fcnt32 + 1) & 0xFFFFFFFF
        fcnt16 = fcnt32 & 0xFFFF
        temp = read_temperature()
        frm = encode_temp_centi(temp)                 # 2 bytes payload
        mhdr=b"\x40"; fctrl=b"\x80"; fcnt_le=fcnt16.to_bytes(2,"little"); fport=b"\x01"
        enc = enc_frmpayload(app_skey, devaddr, frm, fcnt16)
        mac = devaddr[::-1]+fctrl+fcnt_le+fport+enc
        mic = data_mic(nwk_skey, devaddr, mhdr+mac, fcnt16)
        frame = mhdr+mac+mic
        freq=random.choice(DATA_FREQS_MHZ)
        send_rxpk(frame, freq, DATA_DATARATE)
        save_fcnt(fcnt32)
        log(f"[UP] temp={temp:.2f}°C FCntUp={fcnt32} freq={freq} DR={DATA_DATARATE} MIC={hexlify(mic).decode().upper()}")
        time.sleep(UPLINK_PERIOD_SEC)

def send_join_loop():
    global last_dn
    while not joined:
        frame, dn = build_join_request(); last_dn=dn
        freq=random.choice(JOIN_FREQS_MHZ)
        send_rxpk(frame, freq, JOIN_DATARATE)
        time.sleep(5)

# ---------- main ----------
def main():
    # background GW tasks
    threading.Thread(target=recv_loop, daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(lambda: push_data({"stat":{"time":datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT")}}), 30)
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX}  Router={TTN_SERVER}:{PORT}")
    print(f"[INFO] Using AS923-1 join freqs {JOIN_FREQS_MHZ} DR={JOIN_DATARATE}, data DR={DATA_DATARATE}")

    # start periodic app uplinks (waits until joined)
    threading.Thread(target=send_data_loop, daemon=True).start()

    # keep sending joins until accepted
    send_join_loop()

if __name__=="__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[Main] Stopped.")
