#!/usr/bin/env python3
# lorawan_otaa_autofix_as923.py
# LoRaWAN 1.0.x OTAA simulator using Semtech UDP (AS923-1).
# - Handles Join-Accept encrypted lengths 16/28/32 (pads 28->32 for AES-ECB)
# - Persists session (DevAddr/NwkSKey/AppSKey/FCntUp) to lorawan_session.json
# - On restart: resumes -> sends a confirmed probe -> auto-rejoins if no downlink
# - Sends uplinks exactly every PERIOD_SEC seconds
# - Two app payload modes:
#     "temp"  : FPort=1, int16 LE temperature * 100
#     "multi" : FPort=10, status|battery|temp_scaled|pressure_decibar|humidity|counter
#
# Match your TTS/TTSI app/device settings exactly (EUIs MSB as shown in console).

import socket, json, time, base64, secrets, threading, random, math, struct, os
from datetime import datetime, timezone
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ==================== CONFIG (EDIT) ====================
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"   # UDP router host
PORT       = 1700
GATEWAY_EUI_HEX = "0004A30B001CC532"                            # 8B MSB

# Device credentials (MSB exactly as in Console)
DEV_EUI_HEX  = "70B3D57ED0050B10"
JOIN_EUI_HEX = "1232456845624523"
APP_KEY_HEX  = "8D7C6E5B3A613ACE210E3F98223740D5"

# Region: AS923-1
JOIN_FREQS_MHZ = [923.2, 923.4, 923.6]
JOIN_DATARATE  = "SF10BW125"                 # use "SF9BW125" if your tenant expects DR3
DATA_FREQS_MHZ = [923.2, 923.4, 923.6, 923.8, 924.0, 924.2, 924.4, 924.6]
DATA_DATARATE  = "SF7BW125"

# Uplink payload mode: "temp" (FPort=1) or "multi" (FPort=10)
APP_PAYLOAD_MODE = "multi"

PERIOD_SEC        = 10.0                     # exact 10s spacing
STATE_FILE        = "lorawan_session.json"
PROBE_TIMEOUT_SEC = 6.0
VERBOSE           = True
# ======================================================

def msb_to_lsb(h): return bytes.fromhex(h)[::-1]
def b64e(b): return base64.b64encode(b).decode()
def b64d(s): return base64.b64decode(s + "===")
def cmacd(key, msg): c=CMAC.new(key, ciphermod=AES); c.update(msg); return c.digest()

GATEWAY_EUI = bytes.fromhex(GATEWAY_EUI_HEX)
DEV_EUI  = msb_to_lsb(DEV_EUI_HEX)   # EUIs are LSB on the wire
JOIN_EUI = msb_to_lsb(JOIN_EUI_HEX)
APP_KEY  = bytes.fromhex(APP_KEY_HEX)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); sock.settimeout(2.0)
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

# ---------- session persistence ----------
def save_session(devaddr, nwk_skey, app_skey, fcnt_up):
    s = {
        "devaddr": devaddr.hex().upper(),
        "nwk_skey": nwk_skey.hex().upper(),
        "app_skey": app_skey.hex().upper(),
        "fcnt_up": int(fcnt_up)
    }
    with open(STATE_FILE, "w") as f: json.dump(s, f)
    if VERBOSE: print("[STATE] saved:", s)

def load_session():
    try:
        with open(STATE_FILE) as f: s=json.load(f)
        devaddr  = bytes.fromhex(s["devaddr"])
        nwk_skey = bytes.fromhex(s["nwk_skey"])
        app_skey = bytes.fromhex(s["app_skey"])
        fcnt_up  = int(s["fcnt_up"])
        if VERBOSE: print(f"[STATE] loaded DevAddr={s['devaddr']} FCntUp={fcnt_up}")
        return devaddr, nwk_skey, app_skey, fcnt_up
    except Exception as e:
        if VERBOSE: print("[STATE] no session:", e)
        return None

# ---------- Semtech UDP helpers ----------
def push_data(payload):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",",":")).encode()
    sock.sendto(hdr + body, (TTN_SERVER, PORT))
    if VERBOSE and "rxpk" in payload:
        p=payload["rxpk"][0]; print(f"[GW] PUSH_DATA -> {p['freq']} {p['datr']} len={p['size']}")

def pull_data():
    token = secrets.token_bytes(2)
    sock.sendto(bytes([VER])+token+bytes([PULL_DATA])+GATEWAY_EUI, (TTN_SERVER, PORT))
    if VERBOSE: print("[GW] PULL_DATA sent")

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print("[GW] periodic error:", e)
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

def send_rxpk(frame, freq_mhz, datr):
    rxpk=[{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": round(freq_mhz,4), "stat": 1,
        "modu": "LORA", "datr": datr, "codr": "4/5",
        "rssi": -35, "lsnr": 5.0, "size": len(frame), "data": b64e(frame)
    }]
    push_data({"rxpk": rxpk})

# ---------- LoRaWAN data helpers ----------
def enc_frm(app_skey, devaddr, payload, fcnt16):
    out=bytearray(); c=AES.new(app_skey,AES.MODE_ECB); i=1; dev_le=devaddr[::-1]
    while len(out)<len(payload):
        block=(b"\x01"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([i]))
        s=c.encrypt(block)
        chunk = payload[(i-1)*16:i*16]
        out.extend([chunk[j] ^ s[j] for j in range(len(chunk))])
        i+=1
    return bytes(out)

def data_mic(nwk_skey, devaddr, mhdr_mac, fcnt16):
    dev_le=devaddr[::-1]
    b0=(b"\x49"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([len(mhdr_mac)]))
    return cmacd(nwk_skey, b0+mhdr_mac)[:4]

# ---------- app payloads ----------
_local_counter = 0

def read_temp():
    t=time.time()
    return round(26.0 + 0.5*math.sin(t/180) + random.uniform(-0.15,0.15), 2)

def payload_temp_only():
    """FPort=1: int16 LE temp*100"""
    c = read_temp()
    v = int(round(c*100))
    return struct.pack("<h", v), 1, {"temperature": c}

def payload_multi():
    """
    FPort=10:
      status(u8) | battery%(u8) |
      temp_scaled(uint16 LE = °C*100 + 32768) |
      pressure_decibar(uint16 LE = bar*10) |
      humidity%(u8) |
      counter(uint16 LE)
    """
    global _local_counter
    _local_counter = (_local_counter + 1) & 0xFFFF

    status   = random.choice([0x00, 0x01, 0x10, 0x12, 0x0F])
    battery  = random.randint(50, 100)
    temp_c   = read_temp()
    temp_sc  = int(round(temp_c*100) + 32768)           # map signed to unsigned
    press_b  = round(random.uniform(0.0, 5.0), 1)       # 0..5 bar (demo)
    press_d  = int(press_b*10)                          # decibar
    humid    = random.randint(30, 90)

    payload = bytes([
        status, battery
    ]) + struct.pack("<H", temp_sc) \
      + struct.pack("<H", press_d) \
      + struct.pack("<B", humid) \
      + struct.pack("<H", _local_counter)

    meta = {
        "status": status, "battery%": battery,
        "temperature": temp_c, "pressure_bar": press_b,
        "humidity%": humid, "counter": _local_counter
    }
    return payload, 10, meta

def build_app_payload():
    if APP_PAYLOAD_MODE.lower() == "multi":
        return payload_multi()
    return payload_temp_only()

# ---------- OTAA 1.0.x ----------
_used_dn=set()
def next_devnonce():
    while True:
        x=secrets.randbits(16)
        if x not in _used_dn:
            _used_dn.add(x); return x.to_bytes(2,"little")

def build_join_request():
    mhdr=b"\x00"; dn=next_devnonce()
    msg=mhdr + JOIN_EUI + DEV_EUI + dn
    mic=cmacd(APP_KEY,msg)[:4]
    return msg+mic, dn

def derive_session_keys(app_key, app_nonce, net_id, dev_nonce):
    cipher=AES.new(app_key, AES.MODE_ECB)
    nblk=bytes([0x01])+app_nonce+net_id+dev_nonce+bytes(7)
    ablk=bytes([0x02])+app_nonce+net_id+dev_nonce+bytes(7)
    return cipher.encrypt(nblk), cipher.encrypt(ablk)

def parse_join_accept(join_accept_raw: bytes, dev_nonce: bytes):
    """
    Accepts encrypted payload lengths 16 (no CFList), 28 (variant),
    or 32 (with CFList). For 28, pad to 32 for ECB and ignore trailing.
    """
    mtype = (join_accept_raw[0] >> 5) & 0x07
    if mtype != 0x01:
        print(f"[JOIN] Not Join-Accept, MHDR={join_accept_raw[0]:02X}"); return None

    enc_payload = join_accept_raw[1:-4]   # exclude MHDR and MIC
    L = len(enc_payload)
    if L not in (16, 28, 32):
        print(f"[JOIN][ERR] enc_payload len={L} (expected 16/28/32)")
        print("[JOIN][ERR] Raw PHYPayload:", join_accept_raw.hex().upper())
        return None

    pad_len = (16 - (L % 16)) % 16
    enc_padded = enc_payload + (b"\x00" * pad_len)

    cipher = AES.new(APP_KEY, AES.MODE_ECB)
    dec = b"".join(cipher.encrypt(enc_padded[i:i+16]) for i in range(0, len(enc_padded), 16))
    if len(dec) < 12:
        print("[JOIN][ERR] decrypted too short"); return None

    app_nonce = dec[0:3]            # LSB
    net_id    = dec[3:6]            # LSB
    devaddr   = dec[6:10][::-1]     # store/display MSB

    nwk_skey, app_skey = derive_session_keys(APP_KEY, app_nonce, net_id, dev_nonce)

    print(f"[JOIN] ✅ DevAddr(MSB)={devaddr.hex().upper()}  len(enc)={L} padded={len(enc_padded)}")
    print(f"[JOIN] AppNonce(LSB)={app_nonce.hex().upper()} NetID(LSB)={net_id.hex().upper()}")
    print(f"[JOIN] NwkSKey={nwk_skey.hex().upper()}")
    print(f"[JOIN] AppSKey={app_skey.hex().upper()}")

    save_session(devaddr, nwk_skey, app_skey, 0)
    return devaddr, nwk_skey, app_skey

# ---------- globals ----------
joined=False
devaddr=None; nwk_skey=None; app_skey=None
last_dn=b"\x00\x00"
fcnt32=0
downlink_seen_at = 0.0

# ---------- RX loop (downlinks + Join-Accept) ----------
def recv_loop():
    global joined, devaddr, nwk_skey, app_skey, fcnt32, downlink_seen_at
    while True:
        try: data,_=sock.recvfrom(65535)
        except socket.timeout: continue
        if len(data)<4 or data[0]!=VER: continue
        t=data[3]
        if t==PULL_RESP:
            js=json.loads(data[4:].decode()); b64=js.get("txpk",{}).get("data")
            if not b64: continue
            raw=b64d(b64)
            downlink_seen_at = time.monotonic()
            if not joined:
                parsed = parse_join_accept(raw, last_dn)
                if parsed:
                    token=data[1:3]; sock.sendto(bytes([VER])+token+bytes([TX_ACK]),(TTN_SERVER,PORT))
                    devaddr, nwk_skey, app_skey = parsed
                    fcnt32 = 0
                    joined=True
        elif t==PUSH_ACK and VERBOSE: print("[GW] PUSH_ACK")
        elif t==PULL_ACK and VERBOSE: print("[GW] PULL_ACK")

# ---------- one data uplink ----------
def send_data_uplink(confirmed=False):
    global fcnt32
    fcnt32 = (fcnt32 + 1) & 0xFFFFFFFF
    fcnt16 = fcnt32 & 0xFFFF

    # Build app payload & FPort
    app_payload, fport_val, meta = build_app_payload()

    # Encrypt, build MAC, MIC
    mhdr = b"\x80" if confirmed else b"\x40"   # 0x80 Confirmed Data Up
    fctrl=b"\x80"                              # ADR=1, FOptsLen=0
    fcnt_le=fcnt16.to_bytes(2,"little")
    fport=bytes([fport_val])

    enc = enc_frm(app_skey, devaddr, app_payload, fcnt16)
    mac = devaddr[::-1]+fctrl+fcnt_le+fport+enc
    mic = data_mic(nwk_skey, devaddr, mhdr+mac, fcnt16)
    frame = mhdr+mac+mic

    freq = random.choice(DATA_FREQS_MHZ)
    send_rxpk(frame, freq, DATA_DATARATE)

    tag = "CONFIRMED probe" if confirmed else ("temp" if APP_PAYLOAD_MODE=="temp" else "multi")
    print(f"[UP] {tag} FCntUp={fcnt32} freq={freq} DR={DATA_DATARATE} meta={meta}")
    save_session(devaddr, nwk_skey, app_skey, fcnt32)

# ---------- loops ----------
def join_loop():
    global last_dn
    while not joined:
        frame, dn = build_join_request(); last_dn=dn
        freq=random.choice(JOIN_FREQS_MHZ)
        rxpk=[{
            "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
            "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
            "chan": 0, "rfch": 0, "freq": round(freq,4), "stat": 1,
            "modu": "LORA", "datr": JOIN_DATARATE, "codr": "4/5",
            "rssi": -35, "lsnr": 5.0, "size": len(frame), "data": b64e(frame)
        }]
        push_data({"rxpk": rxpk})
        print(f"[JOIN] JoinReq sent devnonce={dn.hex()} freq={freq} DR={JOIN_DATARATE}")
        time.sleep(5)

def data_loop_exact10s():
    next_t = time.monotonic()
    while True:
        if not joined:
            time.sleep(0.2); next_t = time.monotonic(); continue
        send_data_uplink(False)
        next_t += PERIOD_SEC
        time.sleep(max(0, next_t - time.monotonic()))

# ---------- boot (resume -> probe -> auto-rejoin) ----------
def main():
    threading.Thread(target=recv_loop, daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(lambda: push_data({"stat":{"time":datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT")}}), 30)
    print(f"[GW] Started. Router={TTN_SERVER}:{PORT}  EUI={GATEWAY_EUI_HEX}")
    print(f"[INFO] Join DR={JOIN_DATARATE}  Data DR={DATA_DATARATE}  PayloadMode={APP_PAYLOAD_MODE}")

    resumed = load_session()
    if resumed:
        global devaddr, nwk_skey, app_skey, fcnt32, joined
        devaddr, nwk_skey, app_skey, fcnt32 = resumed
        joined = True
        print("[BOOT] Session found -> skipping join.")
        before = downlink_seen_at; send_data_uplink(confirmed=True)
        t0 = time.monotonic()
        while time.monotonic() - t0 < PROBE_TIMEOUT_SEC and downlink_seen_at == before:
            time.sleep(0.05)
        if downlink_seen_at == before:
            print("[BOOT] No ACK downlink -> stale session. Rejoining...")
            try: os.remove(STATE_FILE)
            except: pass
            joined = False

    if not joined:
        threading.Thread(target=join_loop, daemon=True).start()
        while not joined: time.sleep(0.2)

    threading.Thread(target=data_loop_exact10s, daemon=True).start()
    while True: time.sleep(60)

if __name__ == "__main__":
    try: main()
    except KeyboardInterrupt: print("\n[Main] Stopped.")
