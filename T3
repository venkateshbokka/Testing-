#!/usr/bin/env python3
# lorawan_otaa_autofix_as923.py
# LoRaWAN 1.0.x: correct Join-Accept handling (AES ENCRYPT), persist session,
# resume + confirmed probe (auto-rejoin if stale), and 10s temperature uplinks.
# Built-in Semtech UDP gateway simulator; region AS923-1 by default.

import socket, json, time, base64, secrets, threading, random, math, struct, os
from datetime import datetime, timezone
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ==================== CONFIG (EDIT) ====================
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"   # your UDP router host
PORT       = 1700
GATEWAY_EUI_HEX = "0004A30B001CC532"                            # 8B MSB

# Device credentials (MSB exactly as in Console)
DEV_EUI_HEX  = "70B3D57ED0050B1"
JOIN_EUI_HEX = "1232456845624523"
APP_KEY_HEX  = "8D7C6E5B3A613ACE210E3F98223740D5"

# Region: AS923-1
JOIN_FREQS_MHZ = [923.2, 923.4, 923.6]
JOIN_DATARATE  = "SF10BW125"    # use "SF9BW125" if your tenant expects DR3
DATA_FREQS_MHZ = [923.2, 923.4, 923.6, 923.8, 924.0, 924.2, 924.4, 924.6]
DATA_DATARATE  = "SF7BW125"

PERIOD_SEC        = 10.0
STATE_FILE        = "lorawan_session.json"
PROBE_TIMEOUT_SEC = 6.0
VERBOSE           = True
# ======================================================

# ---------- helpers ----------
def msb_to_lsb(h): return bytes.fromhex(h)[::-1]
def b64e(b): return base64.b64encode(b).decode()
def b64d(s): return base64.b64decode(s + "===")
def cmac(key, msg): c=CMAC.new(key, ciphermod=AES); c.update(msg); return c.digest()

GATEWAY_EUI = bytes.fromhex(GATEWAY_EUI_HEX)
DEV_EUI  = msb_to_lsb(DEV_EUI_HEX)   # EUIs sent LSB in join-req
JOIN_EUI = msb_to_lsb(JOIN_EUI_HEX)
APP_KEY  = bytes.fromhex(APP_KEY_HEX)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); sock.settimeout(2.0)
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

# ---------- session persistence ----------
def save_session(devaddr, nwk_skey, app_skey, fcnt_up):
    s = {
        "devaddr": devaddr.hex().upper(),
        "nwk_skey": nwk_skey.hex().upper(),
        "app_skey": app_skey.hex().upper(),
        "fcnt_up": int(fcnt_up)
    }
    with open(STATE_FILE, "w") as f: json.dump(s, f)
    if VERBOSE: print("[STATE] saved:", s)

def load_session():
    try:
        with open(STATE_FILE) as f: s=json.load(f)
        devaddr  = bytes.fromhex(s["devaddr"])
        nwk_skey = bytes.fromhex(s["nwk_skey"])
        app_skey = bytes.fromhex(s["app_skey"])
        fcnt_up  = int(s["fcnt_up"])
        if VERBOSE: print(f"[STATE] loaded DevAddr={s['devaddr']} FCntUp={fcnt_up}")
        return devaddr, nwk_skey, app_skey, fcnt_up
    except Exception as e:
        if VERBOSE: print("[STATE] no session:", e)
        return None

# ---------- Semtech UDP helpers ----------
def push_data(payload):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",",":")).encode()
    sock.sendto(hdr + body, (TTN_SERVER, PORT))
    if VERBOSE and "rxpk" in payload:
        p=payload["rxpk"][0]; print(f"[GW] PUSH_DATA -> freq={p['freq']} DR={p['datr']} len={p['size']}")

def pull_data():
    token = secrets.token_bytes(2)
    sock.sendto(bytes([VER])+token+bytes([PULL_DATA])+GATEWAY_EUI, (TTN_SERVER, PORT))
    if VERBOSE: print("[GW] PULL_DATA sent")

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print("[GW] periodic error:", e)
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

def send_rxpk(frame, freq_mhz, datr):
    rxpk=[{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": round(freq_mhz,4), "stat": 1,
        "modu": "LORA", "datr": datr, "codr": "4/5",
        "rssi": -35, "lsnr": 5.0, "size": len(frame), "data": b64e(frame)
    }]
    push_data({"rxpk": rxpk})

# ---------- LoRaWAN data helpers ----------
def enc_frm(app_skey, devaddr, payload, fcnt16):
    out=bytearray(); c=AES.new(app_skey,AES.MODE_ECB); i=1; dev_le=devaddr[::-1]
    while len(out)<len(payload):
        block=(b"\x01"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([i]))
        s=c.encrypt(block)
        chunk = payload[(i-1)*16:i*16]
        out.extend([chunk[j] ^ s[j] for j in range(len(chunk))])
        i+=1
    return bytes(out)

def data_mic(nwk_skey, devaddr, mhdr_mac, fcnt16):
    dev_le=devaddr[::-1]
    b0=(b"\x49"+b"\x00"*4+b"\x00"+dev_le+fcnt16.to_bytes(4,"little")+b"\x00"+bytes([len(mhdr_mac)]))
    return cmac(nwk_skey, b0+mhdr_mac)[:4]

def read_temp():
    t=time.time()
    return round(26.0 + 0.5*math.sin(t/180) + random.uniform(-0.15,0.15), 2)

def enc_temp_bytes(celsius):
    v=int(round(celsius*100)); return struct.pack("<h", v)  # int16 LE

# ---------- OTAA 1.0.x (strict Join-Accept parser) ----------
_used_dn=set()
def next_devnonce():
    while True:
        x=secrets.randbits(16)
        if x not in _used_dn:
            _used_dn.add(x); return x.to_bytes(2,"little")

def build_join_request():
    mhdr=b"\x00"; dn=next_devnonce()
    msg=mhdr + JOIN_EUI + DEV_EUI + dn
    mic=cmac(APP_KEY,msg)[:4]
    return msg+mic, dn

def derive_session_keys(app_key, app_nonce, net_id, dev_nonce):
    cipher=AES.new(app_key, AES.MODE_ECB)
    nblk=bytes([0x01])+app_nonce+net_id+dev_nonce+bytes(7)
    ablk=bytes([0x02])+app_nonce+net_id+dev_nonce+bytes(7)
    return cipher.encrypt(nblk), cipher.encrypt(ablk)

def parse_join_accept(join_accept_raw: bytes, dev_nonce: bytes):
    # MHDR must be Join-Accept (MType=001)
    mtype = (join_accept_raw[0] >> 5) & 0x07
    if mtype != 0x01:
        print(f"[JOIN] Not Join-Accept, MHDR={join_accept_raw[0]:02X}"); return None

    enc_payload = join_accept_raw[1:-4]     # exclude MHDR and MIC
    mic        = join_accept_raw[-4:]

    # Must be exactly 16 (no CFList) or 32 (with CFList)
    if len(enc_payload) not in (16, 32):
        print(f"[JOIN][ERR] enc_payload len={len(enc_payload)} (expected 16 or 32)")
        print("[JOIN][ERR] Raw PHYPayload:", join_accept_raw.hex().upper())
        return None

    # Device 'decrypt' = AES-ECB ENCRYPT block-by-block with AppKey
    cipher = AES.new(APP_KEY, AES.MODE_ECB)
    dec = b''.join(cipher.encrypt(enc_payload[i:i+16]) for i in range(0, len(enc_payload), 16))

    # Fixed fields
    app_nonce = dec[0:3]                # LSB
    net_id    = dec[3:6]                # LSB
    devaddr   = dec[6:10][::-1]         # MSB for storage
    # dl_settings = dec[10]; rx_delay = dec[11]  # available if you need

    nwk_skey, app_skey = derive_session_keys(APP_KEY, app_nonce, net_id, dev_nonce)

    print(f"[JOIN] ✅ DevAddr(MSB)={devaddr.hex().upper()}")
    print(f"[JOIN] AppNonce(LSB)={app_nonce.hex().upper()} NetID(LSB)={net_id.hex().upper()}")
    print(f"[JOIN] NwkSKey={nwk_skey.hex().upper()}")
    print(f"[JOIN] AppSKey={app_skey.hex().upper()}")

    save_session(devaddr, nwk_skey, app_skey, 0)
    return devaddr, nwk_skey, app_skey

# ---------- globals ----------
joined=False
devaddr=None; nwk_skey=None; app_skey=None
last_dn=b"\x00\x00"
fcnt32=0
downlink_seen_at = 0.0

# ---------- RX loop (handles all downlinks) ----------
def recv_loop():
    global joined, devaddr, nwk_skey, app_skey, fcnt32, downlink_seen_at
    while True:
        try: data,_=sock.recvfrom(65535)
        except socket.timeout: continue
        if len(data)<4 or data[0]!=VER: continue
        t=data[3]
        if t==PULL_RESP:
            js=json.loads(data[4:].decode()); b64=js.get("txpk",{}).get("data")
            if not b64: continue
            raw=b64d(b64)
            downlink_seen_at = time.monotonic()
            if not joined:
                parsed = parse_join_accept(raw, last_dn)
                if parsed:
                    token=data[1:3]; sock.sendto(bytes([VER])+token+bytes([TX_ACK]),(TTN_SERVER,PORT))
                    devaddr, nwk_skey, app_skey = parsed
                    fcnt32 = 0
                    joined=True
        elif t==PUSH_ACK and VERBOSE: print("[GW] PUSH_ACK")
        elif t==PULL_ACK and VERBOSE: print("[GW] PULL_ACK")

# ---------- one data uplink ----------
def send_data_uplink(confirmed=False):
    global fcnt32
    fcnt32 = (fcnt32 + 1) & 0xFFFFFFFF
    fcnt16 = fcnt32 & 0xFFFF
    temp = read_temp()
    payload = enc_temp_bytes(temp)
    mhdr = b"\x80" if confirmed else b"\x40"   # 0x80 Confirmed Data Up
    fctrl=b"\x80"; fcnt_le=fcnt16.to_bytes(2,"little"); fport=b"\x01"
    enc = enc_frm(app_skey, devaddr, payload, fcnt16)
    mac = devaddr[::-1]+fctrl+fcnt_le+fport+enc
    mic = data_mic(nwk_skey, devaddr, mhdr+mac, fcnt16)
    frame = mhdr+mac+mic
    freq = random.choice(DATA_FREQS_MHZ)
    send_rxpk(frame, freq, DATA_DATARATE)
    if confirmed:
        print(f"[UP★] CONFIRMED probe FCntUp={fcnt32} freq={freq} DR={DATA_DATARATE}")
    else:
        print(f"[UP] temp={temp:.2f}°C FCntUp={fcnt32} freq={freq} DR={DATA_DATARATE}")
    save_session(devaddr, nwk_skey, app_skey, fcnt32)

# ---------- loops ----------
def join_loop():
    global last_dn
    while not joined:
        frame, dn = build_join_request(); last_dn=dn
        freq=random.choice(JOIN_FREQS_MHZ)
        rxpk=[{
            "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
            "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
            "chan": 0, "rfch": 0, "freq": round(freq,4), "stat": 1,
            "modu": "LORA", "datr": JOIN_DATARATE, "codr": "4/5",
            "rssi": -35, "lsnr": 5.0, "size": len(frame), "data": b64e(frame)
        }]
        push_data({"rxpk": rxpk})
        print(f"[JOIN] JoinReq sent devnonce={dn.hex()} freq={freq} DR={JOIN_DATARATE}")
        time.sleep(5)

def data_loop_exact10s():
    next_t = time.monotonic()
    while True:
        if not joined:
            time.sleep(0.2); next_t = time.monotonic(); continue
        send_data_uplink(False)
        next_t += PERIOD_SEC
        time.sleep(max(0, next_t - time.monotonic()))

# ---------- boot (resume -> probe -> auto-rejoin) ----------
def main():
    threading.Thread(target=recv_loop, daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(lambda: push_data({"stat":{"time":datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT")}}), 30)
    print(f"[GW] Started. Router={TTN_SERVER}:{PORT}  EUI={GATEWAY_EUI_HEX}")
    print(f"[INFO] Join DR={JOIN_DATARATE}  Data DR={DATA_DATARATE}")

    resumed = load_session()
    if resumed:
        global devaddr, nwk_skey, app_skey, fcnt32, joined
        devaddr, nwk_skey, app_skey, fcnt32 = resumed
        joined = True
        print("[BOOT] Session found -> skipping join.")
        # Confirmed probe; if no downlink scheduled in RX1/RX2, assume stale keys/counter
        before = downlink_seen_at; send_data_uplink(confirmed=True)
        t0 = time.monotonic()
        while time.monotonic() - t0 < PROBE_TIMEOUT_SEC and downlink_seen_at == before:
            time.sleep(0.05)
        if downlink_seen_at == before:
            print("[BOOT] No ACK downlink -> stale session. Rejoining...")
            try: os.remove(STATE_FILE)
            except: pass
            joined = False

    if not joined:
        threading.Thread(target=join_loop, daemon=True).start()
        while not joined: time.sleep(0.2)

    threading.Thread(target=data_loop_exact10s, daemon=True).start()
    while True: time.sleep(60)

if __name__ == "__main__":
    try: main()
    except KeyboardInterrupt: print("\n[Main] Stopped.")
