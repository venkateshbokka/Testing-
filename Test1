#!/usr/bin/env python3
# lorawan_single.py
# One file: Semtech UDP gateway + OTAA end-device (LoRaWAN 1.0.x)

import socket, json, time, base64, struct, secrets, threading, random
from datetime import datetime, timezone
from binascii import hexlify
from Crypto.Cipher import AES
from Crypto.Hash import CMAC

# ===================== USER CONFIG (EDIT) =====================
# Your The Things Stack UDP router host + port
TTN_SERVER = "learningnetwork.ms1.cloud.thethings.industries"
PORT       = 1700

# Simulated Gateway EUI (MSB, 16 hex chars = 8 bytes)
GATEWAY_EUI_HEX = "0004A30B001CC532"

# Device credentials (MSB exactly as in TTS Console)
DEV_EUI_HEX  = "70B3D57ED0050B1"
JOIN_EUI_HEX = "1232456845624523"
APP_KEY_HEX  = "8D7C6E5B3A613ACE210E3F98223740D5"

# Region / radio (AS923 example; adjust if needed)
FREQUENCIES_MHZ = [922.0, 922.2, 922.4, 922.6, 922.8]
DATARATE        = "SF7BW125"
CODR            = "4/5"
RSSI, LSNR      = -35, 5.0
VERBOSE         = True
# =============================================================

# ---------- helpers ----------
def msb_to_lsb(hex_str): return bytes.fromhex(hex_str)[::-1]
def b64e(b): return base64.b64encode(b).decode("ascii")
def b64d(s): return base64.b64decode(s + "===")

# Convert config
GATEWAY_EUI = bytes.fromhex(GATEWAY_EUI_HEX)
DEV_EUI  = msb_to_lsb(DEV_EUI_HEX)
JOIN_EUI = msb_to_lsb(JOIN_EUI_HEX)
APP_KEY  = bytes.fromhex(APP_KEY_HEX)

print(f"[INFO] DevEUI  MSB={DEV_EUI_HEX}  LSB={hexlify(DEV_EUI).decode()}")
print(f"[INFO] JoinEUI MSB={JOIN_EUI_HEX} LSB={hexlify(JOIN_EUI).decode()}")
print(f"[INFO] AppKey  MSB={APP_KEY_HEX}")

# UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)

# Semtech UDP constants
VER=2; PUSH_DATA=0x00; PUSH_ACK=0x01; PULL_DATA=0x02; PULL_RESP=0x03; PULL_ACK=0x04; TX_ACK=0x05

# ---------- Device (LoRaWAN 1.0.x) ----------
_used_nonces=set()
def next_devnonce():
    while True:
        dn = secrets.randbits(16)
        if dn not in _used_nonces:
            _used_nonces.add(dn)
            return dn.to_bytes(2, "little")

def join_mic(msg: bytes, app_key: bytes) -> bytes:
    c = CMAC.new(app_key, ciphermod=AES)
    c.update(msg)
    return c.digest()[:4]

def build_join_request():
    mhdr = b"\x00"  # Join-Request
    dev_nonce = next_devnonce()
    msg = mhdr + JOIN_EUI + DEV_EUI + dev_nonce
    mic = join_mic(msg, APP_KEY)
    frame = msg + mic
    print(f"[Device] JoinReq devnonce={dev_nonce.hex()} mic={mic.hex()}")
    return frame, dev_nonce

def parse_join_accept(raw: bytes, dev_nonce: bytes):
    if (raw[0] >> 5) != 0x01:
        print("[Device] Downlink is not Join-Accept"); return None
    enc = raw[1:17]  # decrypt minimal 16B payload
    dec = AES.new(APP_KEY, AES.MODE_ECB).decrypt(enc)
    app_nonce = dec[0:3]; net_id = dec[3:6]; devaddr_le = dec[6:10]
    dev_addr = devaddr_le[::-1]

    def s_key(prefix):
        material = bytes([prefix]) + app_nonce + net_id + dev_nonce + b"\x00"*7
        return AES.new(APP_KEY, AES.MODE_ECB).encrypt(material)
    nwk_skey = s_key(0x01)
    app_skey = s_key(0x02)

    print(f"[Device] âœ… Join-Accept OK  DevAddr={dev_addr.hex().upper()}")
    print(f"[Device] NwkSKey={nwk_skey.hex().upper()}")
    print(f"[Device] AppSKey={app_skey.hex().upper()}")
    return dev_addr, nwk_skey, app_skey

def encrypt_frmpayload(app_skey: bytes, dev_addr: bytes, payload: bytes, fcnt: int) -> bytes:
    out = bytearray(); cipher = AES.new(app_skey, AES.MODE_ECB)
    i = 1; dev_le = dev_addr[::-1]
    while len(out) < len(payload):
        block_a = (b"\x01" + b"\x00"*4 + b"\x00" + dev_le +
                   fcnt.to_bytes(4, "little") + b"\x00" + bytes([i]))
        s = cipher.encrypt(block_a)
        for b in payload[(i-1)*16:i*16]:
            out.append(b ^ s[len(out)%16])
        i += 1
    return bytes(out[:len(payload)])

def data_mic(nwk_skey: bytes, dev_addr: bytes, mhdr_mac: bytes, fcnt: int) -> bytes:
    dev_le = dev_addr[::-1]
    b0 = (b"\x49" + b"\x00"*4 + b"\x00" + dev_le +
          fcnt.to_bytes(4, "little") + b"\x00" + bytes([len(mhdr_mac)]))
    c = CMAC.new(nwk_skey, ciphermod=AES); c.update(b0 + mhdr_mac)
    return c.digest()[:4]

# ---------- Gateway (Semtech UDP) ----------
def push_data(payload: dict):
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PUSH_DATA]) + GATEWAY_EUI
    body = json.dumps(payload, separators=(",", ":")).encode()
    if VERBOSE:
        print("[GW VERBOSE] PUSH_DATA JSON -> TTS")
        print(json.dumps(payload, indent=2))
    try:
        sock.sendto(hdr + body, (TTN_SERVER, PORT))
    except Exception as e:
        print(f"[GW] send error: {e}")

def pull_data():
    token = secrets.token_bytes(2)
    hdr = bytes([VER]) + token + bytes([PULL_DATA]) + GATEWAY_EUI
    try:
        sock.sendto(hdr, (TTN_SERVER, PORT))
        if VERBOSE: print("[GW VERBOSE] PULL_DATA sent")
    except Exception as e:
        print(f"[GW] pull error: {e}")

def send_status():
    payload = {"stat": {
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S GMT"),
        "lati": 23.0, "long": 72.0, "alti": 20, "rxnb": 0, "rxok": 0,
        "rxfw": 0, "ackr": 0.0, "dwnb": 0, "txnb": 0
    }}
    push_data(payload)

def send_uplink(frame_bytes: bytes, freq_mhz=None, datr=None):
    freq = round(freq_mhz if freq_mhz else random.choice(FREQUENCIES_MHZ), 3)
    datr = datr or DATARATE
    rxpk = [{
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
        "tmst": int(time.time()*1_000_000) & 0xFFFFFFFF,
        "chan": 0, "rfch": 0, "freq": freq, "stat": 1,
        "modu": "LORA", "datr": datr, "codr": CODR,
        "rssi": RSSI, "lsnr": LSNR, "size": len(frame_bytes),
        "data": b64e(frame_bytes)
    }]
    push_data({"rxpk": rxpk})
    print(f"[GW] Uplink sent freq={freq} datr={datr} size={len(frame_bytes)}")

def recv_loop(on_downlink):
    while True:
        try:
            data, _ = sock.recvfrom(65535)
        except socket.timeout:
            continue
        if len(data) < 4 or data[0] != VER: 
            continue
        ptype = data[3]
        if ptype == PUSH_ACK:
            print("[GW] PUSH_ACK (uplink acknowledged)")
        elif ptype == PULL_ACK and VERBOSE:
            print("[GW VERBOSE] PULL_ACK")
        elif ptype == PULL_RESP:
            try:
                js = json.loads(data[4:].decode())
                b64 = js.get("txpk", {}).get("data")
                if b64:
                    raw = b64d(b64)
                    print(f"[GW] Downlink received ({len(raw)} bytes)")
                    if VERBOSE:
                        print("[GW VERBOSE] DL:", hexlify(raw).decode())
                    on_downlink(raw)
                # respond with TX_ACK
                token = data[1:3]
                sock.sendto(bytes([VER]) + token + bytes([TX_ACK]), (TTN_SERVER, PORT))
            except Exception as e:
                print(f"[GW] PULL_RESP parse error: {e}")

def schedule_every(fn, sec):
    def loop():
        while True:
            try: fn()
            except Exception as e: print(f"[GW] periodic error: {e}")
            time.sleep(sec)
    threading.Thread(target=loop, daemon=True).start()

# ---------- Wiring / main ----------
joined = False
last_devnonce = None
dev_addr = None
nwk_skey = None
app_skey = None
fcnt = 0

def on_downlink(raw: bytes):
    global joined, dev_addr, nwk_skey, app_skey
    if not joined:
        parsed = parse_join_accept(raw, last_devnonce)
        if parsed:
            dev_addr, nwk_skey, app_skey = parsed
            joined = True

def send_data_loop():
    global fcnt
    while True:
        if not joined:
            time.sleep(1); continue
        fcnt = (fcnt + 1) & 0xFFFF
        mhdr = b"\x40"                         # UnconfirmedDataUp
        fctrl = b"\x80"
        fcnt_le = fcnt.to_bytes(2, "little")
        fport = b"\x01"
        payload = f"temp:{25 + (fcnt % 5)}".encode()
        enc = encrypt_frmpayload(app_skey, dev_addr, payload, fcnt)
        mac_payload = dev_addr[::-1] + fctrl + fcnt_le + fport + enc
        mic = data_mic(nwk_skey, dev_addr, mhdr + mac_payload, fcnt)
        frame = mhdr + mac_payload + mic
        send_uplink(frame)
        time.sleep(10)

def join_loop():
    global last_devnonce
    while not joined:
        frame, dn = build_join_request()
        last_devnonce = dn
        send_uplink(frame)
        print("[Device] JoinReq sent")
        time.sleep(5)

def main():
    # start gateway background workers
    threading.Thread(target=recv_loop, args=(on_downlink,), daemon=True).start()
    schedule_every(pull_data, 5)
    schedule_every(send_status, 30)
    print(f"[GW] Started. EUI={GATEWAY_EUI_HEX} -> {TTN_SERVER}:{PORT}")

    # start periodic app uplinks (will wait until joined)
    threading.Thread(target=send_data_loop, daemon=True).start()

    # keep sending join requests until accepted
    join_loop()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[Main] Stopped.")
